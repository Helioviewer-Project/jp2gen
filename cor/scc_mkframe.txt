;+
;$Id: scc_mkframe.pro,v 1.66 2009/06/24 12:09:37 secchib Exp $
;
; Project     : STEREO - SECCHI
;                   
; Name        : SCC_MKFRAME
;               
; Purpose     : Generates a SECCHI movie frame.
;               
; Explanation : This procedure uses parameters and keywords from SCC_MKMOVIE to generate
;               a single frame.
;               
; Use         : For the average user, SCC_MKFRAME should not be called on it's own. See scc_mkmovie.pro or
;   	    	scc_mk_image.pro for examples.
;    
; Inputs      : Most of the inputs correspond to keywords in SCC_MKMOVIE.pro. See keyword definitions
;   	    	and call to scc_mkframe in scc_mkmovie.pro.
;               
; Outputs     : byte-scaled image array and header structure
;               
; Keywords    : /VERBOSE   : Print more info about each frame
;    	    	/GETSUBFIELD: If set, then use box_cursor to retrieve subfield from first frame
;		/AUTOMAX   : Compute bmin and bmax based on median (for EUVI, calls scc_bytscl.pro)
;   	    	/FMASK	   : Apply a mask from file in $SECCHI_CAL
;   	    	/NOPOPUP   : Do not display frame after processing
;   	    	/TWO	     Retrieve corresponding image from other spacecraft and make a B/A movie.
;   	    	    	    Set =2 to display A on left and B on right (default for HI)
;
; Calls       : secchi_prep.pro, scc_sun_center.pro. Option or Input dependent: tvcircle.pro, box_cursor2.pro, 
;   	    	scc_putin_array.pro, scc_add_logo.pro, scc_bytscl.pro, sharpen.pro, scc_getbkgimg.pro, hi_prep, ;   	    	    	leefilt.pro, rot.pro, get_stereo_lonlat.pro, getsccsecpix.pro 
;
; Side effects: Creates pixmap.
;               
; Category    : Image Display calibration inout
;               
; See Also    : SCC_MKMOVIE.PRO calls this routine.
;               WSCC_MKMOVIE.PRO is a widget front-end to SCC_MKMOVIE.PRO.
;               
; Prev. Hist. : Removed sections from WMKMOVIE and modified for SECCHI. 
;
; History     : Ed Esfandiari, NRL, Sep 2006.
;               
;-            
;$Log: scc_mkframe.pro,v $
;Revision 1.66  2009/06/24 12:09:37  secchib
;added findx to WSCC_MKMOVIE_COMMON block
;
;Revision 1.65  2009/03/18 19:13:26  nathan
;Changed meaning of opts[10] from A and B use all to A and B put A on left
;(TWO=2)
;
;Revision 1.64  2008/11/10 17:58:37  mcnutt
;return ERROR string for bimage if image is skipped do to an error
;
;Revision 1.63  2008/11/05 17:37:35  thompson
;Use select_windows instead of set_plot for better cross-platform compatibility
;Increase search window for pB series:
;
;Revision 1.62  2008-10-28 17:33:48  mcnutt
;added keyword nan_off to scc_roll_image call
;
;Revision 1.61  2008/10/21 17:36:44  mcnutt
;added object option to add Earth, SOHO and other stereo sc positions to HI2 movies
;
;Revision 1.60  2008/10/10 18:25:07  mcnutt
;print hours between image for running difference only
;
;Revision 1.59  2008/10/10 18:17:03  mcnutt
;corrected running difference offset
;
;Revision 1.58  2008/10/08 21:52:09  nathan
;fixed refsz bug
;
;Revision 1.57  2008/10/08 21:43:00  nathan
;fixed rdiff=1 case
;
;Revision 1.56  2008/09/26 23:20:54  secchib
;nr - fix case where running_diff is undefined
;
;Revision 1.55  2008/09/26 19:33:37  nathan
;updated hi_prep for imgm; implement /AUTOMAX for bmax/bmin * median
;
;Revision 1.54  2008/09/26 19:06:02  mcnutt
;added lag variable (n previous images) in running differences movie type
;
;Revision 1.53  2008/09/25 15:33:12  nathan
;Added DOMEDIAN= kw; removed a 2sec wait; if bmin =und or =bmax, then return
;before bytscl
;
;Revision 1.52  2008/09/24 17:18:48  nathan
;use /interp for dorotate to get rid of banding in linear features
;
;Revision 1.51  2008/09/22 16:11:39  nathan
;put time on display image even if NOT /times
;
;Revision 1.50  2008/09/18 21:53:53  nathan
;Added SMOOTH_BOX option; do hi_prep on model before applying model to image;
;use scc_add_datetime to apply timestamp
;
;Revision 1.49  2008/09/15 18:57:10  nathan
;committed 9/9,12 changes
;
;
; 080912,nr - do precommcorrect if crpix = NaN
; 080909,nr - fixed case where nocal,noexpcorr are undefined
;
;Revision 1.48  2008/08/26 20:38:09  nathan
;correct for bad polar value in cor2 double image headers
;
;Revision 1.47  2008/08/25 16:57:48  nathan
;Renamed ratio to doratio so as not to conflict with ratio.pro; added /PHOTOCAL;
;rewrote how keywords are set for secchi_prep, hi_prep, and cor if model is used
;to fix problems with calibration being applied twice; fixed use of first frame
;for base frame; implemented calibration for COR if model is used with DIFF
;
;Revision 1.46  2008/08/20 17:17:03  mcnutt
;works with wscc_mkmovie with pB series options
;
;Revision 1.45  2008/08/14 16:40:11  nathan
;account for img_pan when computing new crpix for subfield
;
;Revision 1.44  2008/08/13 16:05:22  nathan
;fixed bug with polar check (last edit)
;
;Revision 1.43  2008/08/08 23:23:33  nathan
;Check for consistency of polar/wavelnth; extended common scc_movie; retabbed
;secchi_prep section
;
;Revision 1.42  2008/06/20 17:07:51  mcnutt
;does not normalize hi ab movies
;
;Revision 1.41  2008/06/10 14:38:53  secchia
;defined pbser if keyword not set
;
;Revision 1.40  2008/05/29 18:28:32  mcnutt
;made total brightness changes compatable with scc_mk_image
;
;Revision 1.39  2008/05/28 15:55:52  mcnutt
;returns blank frame if PB series is incomplete
;
;Revision 1.38  2008/05/22 18:34:25  mcnutt
;added total brightness option for COR1 and COR2
;
;Revision 1.37  2008/05/20 19:44:37  nathan
;set bimage before skipim
;
;Revision 1.36  2008/05/20 19:05:14  nathan
;use scc_roll_image.pro to correct roll; update common wscc_mkmovie_common
;
;Revision 1.35  2008/05/02 20:00:52  nathan
;define sunc type double; add /nowarp to secchi_prep call
;
;Revision 1.34  2008/04/29 15:39:02  nathan
;redefined first = yloc eq 0; implement box_ref[ab]
;
;Revision 1.33  2008/04/28 19:23:35  nathan
;ensure do not use_model if euvi
;
;Revision 1.32  2008/04/21 15:52:25  nathan
;changed first to look at yloc  not i
;
;Revision 1.31  2008/04/15 20:28:22  nathan
;Update for using Ahead first if /TWO; do side-by-side in mkframe instead
;of scc_mkmovie.pro
;
;Revision 1.30  2008/04/14 15:59:24  nathan
;added daily_med option for use_model
;
;Revision 1.29  2008/04/08 16:37:46  nathan
;set datecolor special for EUVI 171
;
;Revision 1.28  2008/04/04 19:01:20  nathan
;Use sun center not crpix for /DOROTATE; do not DOROTATE if /TWO; apply
;scc_normalize two both A and B for epipolar plane; save binned mask in
;common block and apply scc_normalize to it if applicable; decrease radius
;of outer mask for cor2
;
;Revision 1.27  2008/04/02 16:05:31  nathan
;implemented /TWO
;
;Revision 1.26  2008/03/31 20:29:17  nathan
;always set /bkgimg_off in secchi_prep (for COR1)
;
;Revision 1.25  2008/03/31 19:33:28  nathan
;Initial implementation of /TWO for displaying A and B next to each other.
;To do this required moving the window and tv of final frame to scc_mkframe.pro
;loop.
;
;Revision 1.24  2008/03/11 19:42:17  nathan
;Updated header info; use same fillcol for A and B
;
;Revision 1.23  2008/03/05 17:28:54  nathan
;updated auto-scaling for euvi; added saturation_limit=16384 for HI
;
;Revision 1.22  2008/02/27 17:31:00  mcnutt
;finished removing keyword wsccmv
;
;Revision 1.21  2008/02/27 17:00:09  mcnutt
;removed keyword wsccmv and uses common block WSCC_MKMOVIE_COMMON always
;
;Revision 1.20  2008/02/27 14:18:01  mcnutt
;returns coords from getsubfield to wscc_mkmovie using WSCC_MKMOVIE_COMMON
;
;Revision 1.19  2008/02/26 16:54:23  mcnutt
;added quick fix for getsubfield hsize and vsize
;
;Revision 1.18  2008/02/22 22:49:19  nathan
;Added /GETSUBFIELD -- still need to see about returning COORDS to wscc_mkmovie
;display; implemented foutsize for cases where output is bigger than native
;(such as 2048x2048 HI); rearranged some of the set_plot and window calls
;
;Revision 1.17  2008/02/22 15:40:48  nathan
;consolidate common block var definitions and update criteria for redefinition
;
;Revision 1.16  2008/02/21 21:47:51  nathan
;changed common block variables to contain separate A and B versions of themselves
;
;Revision 1.15  2008/02/21 13:24:01  mcnutt
;uses Zbuffer instead of xwin for euvi pipeline
;
;Revision 1.14  2008/02/20 21:20:36  nathan
;always dorotate outside of secchi_prep
;
;Revision 1.13  2008/02/13 17:23:49  mcnutt
;added ref image to common block, and options for cor rotote and hi exp correction for use wwith use_model
;
;Revision 1.12  2008/02/12 21:01:12  nathan
;reduced edge masking width; use fixed r_occ_out for cor2
;
;Revision 1.11  2008/02/12 19:41:58  nathan
;fix FILL_COL keyword operation
;
;Revision 1.10  2008/02/08 19:37:40  mcnutt
;added automax for euvi and adds one to fill color so keyword works, changed log to scale to add 3 as done in scc_mk_image and added hiprep key word for scc_mk_image
;
;Revision 1.9  2008/02/01 14:58:22  nathan
;remove common mvmask from scc_mkmovie (define in scc_mkframe only)
;
;Revision 1.8  2008/01/24 17:39:38  nathan
;Use /FULL in secchi_prep call; change mdnotbx threshold
;
;Revision 1.7  2008/01/22 21:21:47  nathan
;added _EXTRA to allow other secchi_prep keywords (such as /rotate_on)
;
;Revision 1.6  2008/01/15 14:47:22  mcnutt
;adjusted in and outer occulter masks for cor2 and euvi added limb as input
;
;Revision 1.5  2008/01/11 19:41:37  mcnutt
;added solar limb keyword outer to work with fmask
;
;Revision 1.4  2008/01/11 16:33:31  nathan
;Permanently moved from dev/movie to secchi/idl/display/movie
;
;Revision 1.3  2008/01/11 15:29:11  mcnutt
;added fmask keyword to use the masks from files and changed scc_add_mvi_logo to scc_add_logo
;
;Revision 1.10  2007/12/19 21:33:30  nathan (last revision in dev/movie)
;added /bkgimg_off to secchi_prep call for cor1
;
;Revision 1.9  2007/12/10 22:27:44  nathan
;Implemented subfields; moved much of frame-specific settings from mkmovie to mkframe;
;changed some of the mkframe input parameters; changed date color cutoff from 100 to 130
;
;Revision 1.8  2007/12/06 21:03:33  nathan
;Decoupled NOCAL and NOEXPCORR; print tel above date; variable charsize and color
;for tel/date
;
;Revision 1.2  2007/10/17 21:48:51  nathan
;latest revision from dev/movie (1.7)
;
;Revision 1.7  2007/10/16 20:30:56  nathan
;change error checking to use -9999 instead of -1
;
;Revision 1.6  2007/10/05 21:06:58  nathan
;Major update for SECCHI, using secchi_prep, and making sure options work
;correctly. Still TBD: image subfields, optimize masks, etc.
;
;Revision 1.5  2007/09/06 14:51:43  nathan
;fix getbkgimg call use scc_add_mvi_logo
;
;Revision 1.4  2007/08/17 15:57:51  herbst
;Mods for N.Sheeley Summer 2007
;
;Revision 1.3  2007/03/28 19:41:00  esfand
;secchi movie routines as of Mar 28, 07
;
;Revision 1.2  2006/10/10 20:27:09  esfand
;removed unused comments
;
;Revision 1.1  2006/10/05 20:50:35  esfand
;first virsion - aee
;
;
; 
;____________________________________________________________________________
;

FUNCTION SCC_MKFRAME,fnamen,tai_all,exp_all,bias_all,rolld,fpwvl_all,filter_all, $
                      hdr,i,startind,img_xy,dofull,bmin,bmax,cam, $
                      box_ref,r_occ,r_occ_out,sunc,r_sun, $
                      linethickness, pan, hsize, vsize, coords, $
                      yloc,win_index,camt,xouts,youts,mask_occ, sunxcen, sunycen, $
                      lg_mask_occ,diff,hide_pylon,use_model,box,no_normal,noexpcorr, $
                      doratio,use_sharp,sharp_fact,sqrt_scl,log_scl,running_diff,unsharp,lee_filt, $
                      fill_col,fixgaps,outer,limb,tiff,png,pict,times,ftimes,dbiasx, NEWBKG= newbkg, $
                      bad_skip,logo,sdir,save,tlen,nocal,skipped, DOMEDIAN=domedian, PHOTOCAL=photocal, $
                      docolor,domask,dorotate, TWO=two, GETSUBFIELD=getsubfield, SMOOTH_BOX=smooth_box, $
		      VERBOSE=verbose,AUTOMAX=automax, FMASK=fmask, nopop=nopop, pbser=pbser,objects=objects, _EXTRA=_extra

common scc_movie, prev, prevhdr, prevbimg, modtai, hdrm, refcmn ,ref_exp,  fillcol, datecolor, firstpol
common mvmask , mvmsk, mskhdr, sunc1
COMMON WSCC_MKMOVIE_COMMON, swmoviev, debug_on, rgb, imgs, coordsab, findx

    IF datatype(yloc) EQ 'UND' THEN yloc=0
    
    ishi=0
    isc2=0
    isc1=0
    IF datatype(cam) EQ 'UND' THEN BEGIN
    	IF rstrmid(fnamen,6,1) EQ 'h' THEN ishi=1
	IF rstrmid(fnamen,6,2) EQ 'c2' THEN isc2=1
	IF rstrmid(fnamen,6,2) EQ 'c1' THEN isc1=1
    ENDIF ELSE BEGIN
    	IF strmid(cam,0,2) eq 'hi' THEN ishi=1
    	IF cam eq 'cor2' THEN isc2=1
    	IF cam eq 'cor1' THEN isc1=1
    ENDELSE


         ;IF n_elements(cache) GT 1 THEN fnamen = get_cache(i,names) ELSE fnamen=names[i]
;
; --Initializations
;
    IF (DATATYPE(bmin) EQ 'UND' OR DATATYPE(bmax) EQ 'UND') THEN automax=1

    IF keyword_set(DEGRID) THEN nodegrid=0 ELSE nodegrid=1
    IF not(keyword_set(pbser)) THEN pbser=0
    IF not(keyword_set(DBIAS)) THEN dbias=0
    IF     keyword_set(DBIAS)  THEN dbiasx=dbias ELSE dbiasx=0

;    
;--BEGIN size math
;
   ; -- ALL we need HERE is pan, which is output FFV size 
    IF keyword_set(VIDEO) THEN BEGIN
    	;tlen =16
	IF not(keyword_set(NY)) THEN coords=[0,2047,257,1792]  ;equatorial region
	tlen =19
	IF not(keyword_set(NX)) THEN nx = 640.
	IF not(keyword_set(NY)) THEN ny = 480.
	IF keyword_set(SQUARE) THEN BEGIN
    	    nx = 480
    	    coords = [0,2047,0,2047]
	ENDIF ELSE BEGIN
    	    IF not(keyword_set(PAN)) THEN pan = nx
	ENDELSE
	xouts=36    	;-- location of timestamp
	youts=34 	;+ (ny-480)/2.
    ENDIF ELSE BEGIN
	IF NOT(keyword_set(NY)) THEN ny=0
	IF     keyword_set(NX)  THEN IF (NOT(keyword_set(NY)) or NY EQ NX) THEN pan =nx
	xouts=10
	youts=10
	;tlen =16
	tlen=19
    ENDELSE

    IF KEYWORD_SET(COORDS) THEN img_xy=coords ELSE img_xy=[0,2047,0,2047]
   

; **
; img_pan, hsize,vsize are the size of the final product, could be subfield
; img0_pan, fhsize, fvsize are for internal use, the size of the full square field of view which comes out of secchi_prep.


    IF keyword_set(PAN) THEN img_pan=pan/2048. ELSE img_pan=0.5     ; default is 1024x1024 (half size). 
    foutsize=fix(img_pan*2048)
    ; need another size var for expanding nominally 1024x1024 images (esp. HI)
    fhsize=foutsize
    ; fhsize is for image processing. foutsize is the final, pre-subfield dimension
    IF (ishi) and foutsize GT 1024 THEN fhsize=1024
    fvsize=fix(img_pan*2048)
;    hsize= fix(img_pan*hsize)
;    vsize= fix(img_pan*vsize)
    img_xy=fix(img_pan*img_xy)
    img0_pan=img_pan

;moved down to be determined after img_pan corrections
    hsize = img_xy[1]-img_xy[0]+1
    vsize = img_xy[3]-img_xy[2]+1


    linethickness=img_pan*4
    
    IF KEYWORD_SET(BOX) THEN BEGIN
    	box1=img_pan*box*fhsize/foutsize
    ENDIF ELSE BEGIN	
    	box1=[176,432,184,440]		; Box around pylon, 8/11/00
    ENDELSE


   IF keyword_set(LABELPOS) THEN BEGIN
	xouts=labelpos[0]
	youts=labelpos[1]
   ENDIF
;
;--END size math
;

;--Initialize common block variables for a and b sides
refsz=size(refcmn)
IF refsz[2] NE fhsize THEN BEGIN
    refcmn = make_array(2,fhsize,fhsize,/float)
    ref_exp = make_array(2,/float)
    prev=make_array(2,fhsize,fhsize,/float)
    prevhdr=make_array(2,value=def_secchi_hdr())
    ;fillcol=make_array(2,/float)
    sunc1=make_array(2,value={xcen:0d,ycen:0d})
    datecolor=bytarr(2)
    IF keyword_set(BOX_REF) THEN box_ref=replicate(box_ref,2) ELSE box_ref=[0.,0.]
ENDIF
;refsz=size(refcmn,/dimensions)
IF refsz[0] EQ 0 THEN fourthd=0 ELSE IF refsz[0] EQ 3 THEN fourthd=1 ELSE fourthd=refsz[4]
if keyword_set(running_diff) THEN $
IF fourthd ne running_diff+1 then begin
    refcmn = make_array(2,fhsize,fhsize,running_diff+1,/float)
    ref_exp = make_array(2,running_diff+1,/double)
endif
    
skipped=0
first = yloc EQ 0	    ; first image displayed
IF yloc LE 0 THEN modtai=[0.,0.]

IF fnamen EQ '' THEN return,bytarr(hsize,vsize) ; this is half of a pair that is not there

    bkgoff=1
    pb=0 & mu=0 & percent=0 ; defaults
    IF keyword_set(doratio) THEN nocal=1	; vignetting/flatfield/photometry irrelevant for doratio
    nocalfac=~keyword_set(PHOTOCAL) 	; calfac is photometry; cal is vignetting/flatfield
    doprecommcorrect=0
    cor1pbdiff=0
    nocalimgval=keyword_set(nocal)	    ; these are values used in secchi_prep
    nocalfacval=nocalfac
    noexpcorrval=keyword_set(noexpcorr)
    ; some cases never do these corrections in secchi_prep 
    ;IF (ishi) THEN  noexpcorrval=1
    IF isc1 or isc2 THEN BEGIN
    	nocalimgval=1
	nocalfacval=1
	; if background is subtracted, need to apply these after, except in case of COR1 pbseries (see below)
    ENDIF
    IF isc2 THEN doprecommcorrect=1 

    IF keyword_set(VERBOSE) THEN quiet=0 ELSE quiet=1
    IF keyword_set(VERBOSE) THEN help,pan,img_pan,fhsize,hsize,nocal,first, fill_col
    IF keyword_set(VERBOSE) THEN wait,2
    ;IF keyword_set(nocal) THEN noexpcorr=1
    REPEAT BEGIN
        file_exists = file_exist(fnamen)
    	image=-9999
    	
    	IF (file_exists) THEN BEGIN
    	    IF datatype(swmoviev) NE 'UND' THEN pbser=swmoviev.pbs
    	    
	    jk=sccreadfits(fnamen,h0,/nodata)
	    ;--Correct for bad header info 
	    IF h0.seb_prog EQ 'DOUBLE' THEN h0.polar=1001
	    ; check for polar/sector match
	    IF ~finite(h0.crpix1) THEN doprecommcorrect=1
	    IF strmid(h0.detector,0,1) EQ 'E' THEN thispol=h0.wavelnth ELSE thispol=h0.polar
	    IF (yloc LE 0) THEN firstpol=thispol
	    IF thispol NE firstpol THEN BEGIN
    	    	print,'Skipping ',fnamen,' because polar/wavelnth of ',trim(thispol),' does not match first value of ',trim(firstpol)
    	    	;wait,2
                 bimage='ERROR -- Skipping '+fnamen+' because polar/wavelnth of '+trim(thispol)+' does not match first value of '+trim(firstpol)
    	    	skipped=1
    	    	GOTO, skipim
	    ENDIF
	    
            if pbser GT 0 then begin
	    ; Set polarization series options here
                  if pbser eq 2 then pB=1 
                  if pbser eq 3 then mu=1 
                  if pbser eq 4 then percent=1 
    	    	if isc1  and keyword_set(USE_MODEL) then begin
    	    	    IF keyword_set(DIFF) THEN BEGIN
			bkgoff=0
    	    		cor1pbdiff=1
    	    		nocalimgval=keyword_set(nocal)	   
    	    		nocalfacval=nocalimgval
		    ENDIF
    	    	endif 
		  if isc2 then cor2key=1 else cor2key=0
        	  st1=strmid(fnamen,strpos(fnamen,'.f')-21,15)
        	  sct=strmid(fnamen,strpos(fnamen,'.f')-1,1)
        	  t1=(strmid(st1,9,2)*60l*60l)+(strmid(st1,11,2)*60l)-60 
 ;       	  t2=(strmid(st1,9,2)*60l*60l)+(strmid(st1,11,2)*60l)+60 
            t2=(strmid(st1,9,2)*60l*60l)+(strmid(st1,11,2)*60l)+60+60      ; sec's ignored...so bump up to next minute.       	  
		  st1t=strmid(st1,0,4)+'-'+strmid(st1,4,2)+'-'+strmid(st1,6,2)+' '+string((t1/(60*60)),'(i2.2)')+':'+string((t1/60-((t1/3600)*60)),'(i2.2)')+':'+strmid(st1,13,2)
		  st2t=strmid(st1,0,4)+'-'+strmid(st1,4,2)+'-'+strmid(st1,6,2)+' '+string((t2/(60*60)),'(i2.2)')+':'+string((t2/60-((t2/3600)*60)),'(i2.2)')+':'+strmid(st1,13,2)
    		  print,'looking for ',cam,' sequence image between ',st1t,' and ',st2t 
        	  s=cor1_pbseries([st1t,st2t],sct,COR2=cor2key)  

        	  IF datatype(s) ne 'STC' THEN return,bytarr(hsize,vsize) ; this is half of a pair that is not there
        	  fnamen=s.filename

             endif

    	    IF ~keyword_set(VERBOSE) THEN print,'Reading ',fnamen
    	    secchi_prep,fnamen, hdr,image0, CALFAC_OFF=nocalfacval, NOCALFAC=~ishi, calimg_off=nocalimgval, /update_hdr_off, $
    	    		OUTSIZE=fhsize,  exptime_off=noexpcorrval, SILENT=quiet, $
			color_on=docolor,smask_on=domask, BKGIMG_OFF=bkgoff, /NOWARP, $
    	    		/FULL, saturation_limit=16384, PRECOMMCORRECT=doprecommcorrect, polariz_on=(pbser GT 0) ,mu=mu,percent=percent,pB=pB, _EXTRA=_extra
     	    image=image0
	    ;--Correct for bad header info 
    	    IF hdr.seb_prog EQ 'DOUBLE' THEN hdr.polar=1001

	    hdr0=hdr
	ENDIF
       IF image(0) EQ -9999 THEN BEGIN
    	    help,image
	    print,fnamen,': READFITS error?'
    	    print,'Pausing 10 seconds....'
    	    wait, 10
                ;print,'Type .cont to continue...'
                ;stop
                ;goto,skipped
    	ENDIF
       ;IF (hdr.naxis1 GT 2048) THEN BEGIN
       ;  fn= strmid(fnamen,rstrpos(fnamen,'/')+1,50)
       ;  message,fn+' image naxis1= '+STRTRIM(hdr.naxis1,2)+' > 2048  -- Making it 2048x2048.',/CONT
;
       ;  hdr.p1col = hdr.p1col > 51
       ;  hdr.p2col = hdr.p2col < 2098
       ;  image= image(hdr.p1col:hdr.p2col,*)

       ;ENDIF
    ENDREP UNTIL image[0] NE -9999
    IF keyword_set(VERBOSE) THEN  BEGIN
    	print,'Image after secchi_prep:'
    	maxmin,image
    	help,noexpcorr
	wait,2
    ENDIF

    ; image is corrected for IP including IPSUM, so ipsum=1
    ;IF keyword_set(noexpcorr) THEN image=image/hdr.exptime
    IF ~keyword_set(NOEXPCORR) and ~ishi THEN hdr.exptime=1.  ; default for secchi_prep

    cam=strlowcase(hdr.detector)
    aorb=STRMID(hdr.obsrvtry,7,1)
    IF aorb EQ 'A' THEN ab=0 ELSE ab=1
    ;maxfac=2.
    ;minfac=0.

    IF KEYWORD_SET(BOX) THEN BEGIN
    	box_img = DOUBLE(image(box1[0]:box1[1],box1[2]:box1[3]))
    	good = WHERE(box_img GT 0)
        IF keyword_set(VERBOSE) THEN help,box_ref,box_img,good
	IF keyword_set(VERBOSE) THEN print,'Using box:',box1
        IF (good(0) GE 0) THEN BEGIN
            box_avg=avg(box_img(good))
            IF keyword_set(VERBOSE) THEN help,box_avg
            IF keyword_set(VERBOSE) THEN maxmin,box_img(good)
	    IF ~keyword_set(BOX_REF) THEN $
	    IF (first) or yloc LT 0 THEN box_ref[ab]=box_avg
            corr_fact = (box_ref[ab]/box_avg)       ;** normalize to counts in box
     	    image = image*corr_fact
    	ENDIF ELSE if keyword_set(VERBOSE) THEN print,'Box is all zeros.'
    ENDIF 



    dumhdr = hdr
    tai= UTC2TAI(STR2UTC(hdr.date_obs))

; **
;

    BREAK_FILE, fnamen, a, dir, name, ext
    IF keyword_set(VERBOSE) THEN help,dbiasx

    image = image -dbiasx

    IF KEYWORD_SET(LG_MASK_OCC) or keyword_set(MASK_OCC) or keyword_set(HIDE_PYLON) THEN $
    rolld[i]=0 ; AEE

    ind0 = WHERE(image LE 0)
        ; ** ind00 is replaced with ind0 and ind0 is is replaced with ind0ref
    ;
    ;--Set base frame
    ;
    IF KEYWORD_SET(USE_MODEL) and ~cor1pbdiff and cam NE 'euvi' and $
    	(first or (tai-modtai[ab] GT 6*3600) or keyword_set(NEWBKG)) THEN BEGIN
    	; refresh every 6 hours min.
	
	    szm = size(use_model)
	    IF keyword_set(VERBOSE) THEN print,'Interval since last model is ',trim((tai-modtai[ab])/3600.),' hours; refreshing...'
    	    IF szm(0) LT 2 THEN BEGIN
        	IF (use_model EQ 2) THEN use_daily=1 ELSE use_daily=0
        	imgm = scc_GETBKGIMG(hdr, OUTHDR=hdrm, DAILY=use_daily, /match, /interpolate,/nonlinearity)       ;, ROLLED=rolld[i])
        	; ** /FFV is 512 or 1024
               PRINT, '%%%SCC_MKMOVIE:Read in back ground Model'

    	    ENDIF ELSE imgm = use_model

	    ; for hi do flat field and exposure correction with desmear before model subtraction OR ratio
    	    ;noexpcorrval=keyword_set(noexpcorr)
	    if (ishi) and (noexpcorrval+nocalimgval LT 2) then begin 
     	    	imgm0=imgm
   		hi_prep,hdr,imgm, saturation_limit=16384, calimg_off=nocalimgval, /update_hdr_off, $
    	    			EXPTIME_OFF=noexpcorrval, OUTSIZE=fhsize,  SILENT=quiet, /calfac_off
    		IF keyword_set(VERBOSE) THEN BEGIN
    		    print,'After hi_prep...'
    		    maxmin,image
    		    print,'hdr.exptime=',hdr.exptime
    		ENDIF
    		;IF keyword_set(doratio) and ~(noexpcorr) THEN image=image*hdr.exptime
    		IF ~(noexpcorr) THEN hdr.exptime=1.
	    endif


    	    IF (N_ELEMENTS(imgm) EQ 1) THEN BEGIN
        	PRINT, '%%%SCC_MKMOVIE: Model not found'
    	    ENDIF ELSE BEGIN
        	refcmn[ab,*,*] = imgm
        	ref_exp[ab] = hdr.exptime
    	    ENDELSE
	    modtai[ab]=tai

    ENDIF ELSE $

    ; IF not model, then first frame or save current frame for running_diff
    IF yloc LT 0 and ~keyword_set(running_diff) THEN refcmn[ab,*,*] = image
    ;IF yloc LT 0 THEN refcmn[ab,*,*] = image
 
    if keyword_set(running_diff) then begin
        for ird=0,running_diff-1 do begin
	   refcmn[ab,*,*,ird]=refcmn[ab,*,*,ird+1] ;shuffle down ref images
           ref_exp[ab,ird]=ref_exp[ab,ird+1]
	endfor
        ref=(reform(refcmn[ab,*,*,0]))<max(image)
    endif else begin
        ref=(reform(refcmn[ab,*,*]))<max(image)
    endelse

    ind0ref=WHERE(ref LE 0)

    

    IF keyword_set(VERBOSE) THEN BEGIN
    	help,smooth_box,diff,doratio,use_sharp,sqrt_scl,log_scl,running_diff,unsharp,fixgaps,lee_filt,automax,noexpcorrval,nocalimgval
    	wait,2
    ENDIF
    
    IF KEYWORD_SET(DIFF) and ~cor1pbdiff THEN image = TEMPORARY(image) - ref 
                              ;** subtract reference image
    IF KEYWORD_SET(doratio) THEN BEGIN
         
	 IF KEYWORD_SET(USE_SHARP) THEN $
            image = SHARPEN(temporary(image), ref, sharp_fact, BOX_SIZE=UNSHARP) $
         ELSE IF KEYWORD_SET(SQRT_SCL) THEN $
	    image = SQRT(TEMPORARY(image)>0) / SQRT(ref>0) $
         ELSE IF KEYWORD_SET(LOG_SCL) THEN $
	    image = ALOG10(TEMPORARY(image)>1) / ALOG10(ref>1) $
         ELSE BEGIN                                     ;** divide by reference image
            nonzero = WHERE(ref NE 0)
	    
            image[nonzero] = TEMPORARY(image[nonzero]) / ref[nonzero]
            uplim=15
            toobig = where(image GT uplim)
         ENDELSE
    ENDIF

    IF KEYWORD_SET(RUNNING_DIFF) THEN BEGIN
         print,running_diff
         refcmn[ab,*,*,running_diff] = image
         image = TEMPORARY(image) - ref                         ;** subtract reference image
	 ref_exp[ab,running_diff] = anytim2tai(hdr.DATE_CMD)
         if yloc ge 0 then begin
	   hdr.exptime=ref_exp[ab,running_diff]-ref_exp[ab,0]
           print,'running difference - Hours between image and ref image = ',hdr.exptime/3600.
         endif
    ENDIF

    nng=0
    IF datatype(bmin) NE 'UND' THEN ngxy=where(image LT bmin or image GT bmax,nng) 
    IF KEYWORD_SET(UNSHARP) AND NOT(KEYWORD_SET(USE_SHARP)) THEN BEGIN
         ;IF unsharp EQ 1 THEN uns=25 ELSE uns=unsharp
	 IF keyword_set(SMOOTH_BOX) THEN uns=(smooth_box>3) ELSE uns=3
	 IF nng GT 0 THEN image[ngxy]=!values.f_nan
	 tmp = SMOOTH(image,uns,/NAN)
         image = TEMPORARY(image) - tmp                         ;** subtract smoothed image
    ENDIF 

    IF keyword_set(SMOOTH_BOX) and ~keyword_set(UNSHARP) and ~keyword_set(USE_SHARP) THEN BEGIN
    	IF nng GT 0 THEN image[ngxy]=!values.f_nan
    	image = smooth(temporary(image),smooth_box,/NAN)
	print,'Applying SMOOTH() with box=',smooth_box
    ENDIF
    IF keyword_set(DOMEDIAN) THEN image = median(temporary(image),domedian)
; for cor1 polarized or cor2 do flat field after model subtraction, if not doratio

    IF ((isc1 and ~pbser) or isc2) and ~keyword_set(DORATIO) THEN BEGIN
    	IF (nocal) THEN calimg=1.0 ELSE calimg = GET_CALIMG(hdr)
    	IF (nocalfac) THEN calfac=1.0 ELSE calfac = GET_CALFAC(hdr)
	IF keyword_set(VERBOSE) THEN BEGIN
	    help,calimg,calfac
	    print,'Range of calimg in denominator: '
	    IF ~(nocal) THEN maxmin,calimg
	ENDIF
    	image=calfac*ratio(temporary(image),float(calimg))
    ENDIF

    IF (cam EQ 'euvi' and keyword_set(AUTOMAX)) THEN BEGIN
    	print,'For EUVI auto-scaling, only LOG_SCL.'
    ENDIF ELSE BEGIN
      IF ( KEYWORD_SET(LOG_SCL) AND NOT(KEYWORD_SET(doratio)) ) THEN BEGIN
          image=image+3
;         b=where(image le 0,dummy)
;         IF dummy ne 0 THEN image(b)=1
          image=ALOG10(image)>0
      ENDIF
      IF ( KEYWORD_SET(SQRT_SCL) AND NOT(KEYWORD_SET(doratio)) ) THEN BEGIN
         image = SQRT((image)>0)
	 ;maxfac=37.
	 ;minfac=0.
      ENDIF
    ENDELSE
    
; ** Use previous image for missing blocks. **

    nz = where (image GT 0,count)
    IF nz(0) NE -1 THEN md0 = median(image(nz)) ELSE md0=0
    IF keyword_set(VERBOSE) THEN help,md0
    IF keyword_set(FIXGAPS) THEN BEGIN
    	IF max(prev[ab,*,*]) EQ 0 THEN prev[ab,*,*]=md0
	prevn=reform(prev[ab,*,*])
    	IF fixgaps EQ 2 and ind0[0] NE -1 THEN image[ind0] = prevn[ind0]
        ;** fill gaps in this img with prev image
    ENDIF
    prev[ab,*,*]=image

    IF keyword_set(AUTOMAX) THEN md = md0 ELSE md=1.

      IF KEYWORD_SET(LEE_FILT) THEN BEGIN
        lf1 = systime(1)
        image = LEEFILT(temporary(image),3,3)   ; ** NBR, set 4/7/99
        lf2 = systime(1)
        IF keyword_set(VERBOSE) THEN print,'Leefilt took',lf2-lf1,' seconds.'
      ENDIF

    bimage=byte(image)
    IF yloc LT 0 THEN goto,skipim   	; first image is base

    if (yloc eq 0) then sunc1[ab] = SCC_SUN_CENTER(hdr,FULL=0)
    sunc=sunc1[ab]

     IF keyword_set(VERBOSE) THEN print,'sunc:',sunc

    ;--Rotate Solar North Up (OFF)
    IF keyword_set(DOROTATE) and ~ishi and ~keyword_set(TWO) THEN BEGIN
    	scc_roll_image,hdr,image, /INTERP , /nan_off   ; --rolls to Solar north up and updates hdr (!)
    	IF keyword_set(VERBOSE) THEN message,'Image rotated to Solar North Up',/info
    ENDIF
;
; -- End image processing -- Start prep for display
;
    prevhdr[ab] = hdr 	; set prevhdr BEFORE any mods from original full image, except roll correction if any
    
; -- If /TWO, need to normalize 2nd image (behind) to match the first one (ahead) before byte-scaling

    hlenz=512/8
    vlenz=hlenz
    y1z=512/2-vlenz/2
    x1z=y1z
    IF keyword_set(TWO) THEN BEGIN
    	; Ahead is first; do for both, because need to rotate to epipolar plane (?)
	hdra=prevhdr[0]
	if ~ishi then image=scc_normalize(temporary(image),hdr,ref_hdr=hdra)
	IF ab THEN BEGIN
	    ; Behind only
	    x1z=(coords[0])/4.
	    y1z=(coords[2])/4.
	    hlenz=(coords[1])/4. - x1z +1
	    vlenz=(coords[3])/4. - y1z +1
    	; TBD
	; --Adjust coord for rotation difference
    	;latlona=euvi_heliographic(hdra,[coords[0],coords[2]],/carrington)
	; location of lower right corner of box on b
    	    if (yloc eq 0) then sunc1[ab] = SCC_SUN_CENTER(hdr,FULL=0)
    	    sunc=sunc1[ab]
	ENDIF
    	IF keyword_set(DOROTATE) THEN print,'NOTE: Rotating image perpendicular to STEREO Mission Plane, NOT to solar north.'
    	device,get_screen_size=ss
    ENDIF 
    x1=x1z
    y1=y1z
    hlen=hlenz
    vlen=vlenz

        ;IF keyword_set(VERBOSE) and count GT 1 THEN maxmin,image(nz)
;stop
    
    ;IF keyword_set(VERBOSE) THEN BEGIN
    print,'Image before bytscl:'
    maxmin,image

    IF (first) and datatype(bmin) NE 'UND' THEN BEGIN
        bmax = md * bmax
        bmin = md * bmin
    	; for now, if /TWO, uses min/max of first B image - nr
    ENDIF

    IF keyword_set(VERBOSE) THEN help,bmin,bmax
    IF keyword_set(VERBOSE) THEN wait,2

    IF (keyword_set(AUTOMAX) and cam eq 'euvi') THEN $
    	bimage=scc_bytscl(image,hdr) ELSE $
    IF datatype(bmin) EQ 'UND' or bmax-bmin EQ 0 THEN $
    	return,image ELSE $ 
    
    	bimage= BYTE(((image > bmin < bmax)-bmin)*(!D.TABLE_SIZE-1)/(bmax-bmin))


    nz = where(bimage NE 0, count)
    IF nz(0) GE 0 THEN img_med=median(bimage(nz)) ELSE img_med=0

      IF keyword_set(BAD_SKIP) THEN BEGIN
                IF img_med GT 200 or img_med LT 30 or count LE 1 THEN BEGIN
                        print,'Skipping ',fnamen
                        maxmin,bimage
                        wait,2
			skipped=1
                        GOTO, skipim
                ENDIF
      ENDIF

;
; -- Get stuff for mask
;
    IF (first) THEN fillcol=img_med
    ; for now, if /TWO, uses min/max of first B image - nr
    IF KEYWORD_SET(FILL_COL) THEN IF fill_col GT 0 THEN fillcol=fill_col-1   ;-1 so it can be set as a keyword >0

    IF KEYWORD_SET(FIXGAPS) THEN BEGIN
    	IF keyword_set(RUNNING_DIFF) and (ind0ref(0) NE -1) THEN bimage(ind0ref) = fillcol
                ;** gaps in reference img
    	IF (ind0(0) NE -1) THEN BEGIN                  ;** gaps in this image
    	    IF ((fixgaps EQ 1) OR (first)) THEN bimage(ind0) = fillcol
    	ENDIF
    ENDIF

    IF cam NE 'euvi' THEN BEGIN
    	szim = SIZE(bimage)
        horx = szim(1)
        ver1 = 0
        ver2 = szim(2)
        edge = (2*img_pan)>1
        bimage(0:edge-1,*)=fillcol               ; mask edge of  bimage
        bimage(horx-edge:horx-1,*)=fillcol
        bimage(*,ver1:ver1+edge-1)=fillcol
    	bimage(*,ver2-edge:ver2-1)=fillcol
    ENDIF

   arcs = hdr.cdelt1  ; plate scale (arcs/pixel), updated in secchi_prep
   IF arcs LE 0.0 THEN  arcs = GETSCCSECPIX(hdr) ; also accounts for summing
   ;arcs = arcs/(dofull*(hdr.sumcol * hdr.ipsum)) ; account for summing
   ;arcs = arcs/dofull
   sec_pix=arcs ;/img_pan*img0_pan   

   ; r_sun is used for cor1 and cor2 to block occulter.
   r_sun = hdr.rsun   ; radius of sun (arcs) FOR FFV - we are still working with square FFV image
   IF (r_sun EQ 0.0) THEN BEGIN ; use spice routines to get radius of sun
     hee_r= GET_STEREO_LONLAT(hdr.date_obs, aorb, $
                              /au, /degrees , system='HEE',_extra=_extra)
     r_sun = (6.96d5 * 648d3 / !dpi / 1.496d8) / hee_r(0) ; convert from radian to arcs
   ENDIF

   r_sun = r_sun/arcs  ; radius of sun (pixels)

   rectify=0

IF KEYWORD_SET(FMASK) THEN BEGIN
    szmvsk=size(mvmsk)
    IF szmvsk[2] NE fhsize THEN mvmsk=make_array(2,fhsize,fhsize,/byte)
    if max(mvmsk[ab,*,*]) EQ 0 or yloc eq 0 then begin 
         r_occ=-1
         CASE STRLOWCASE(hdr.detector) OF
          'cor1' : begin 
	              maskfile=getenv('SECCHI_CAL')+'/cor1_mask.fts'
                      r_occ=r_sun * 1.2
                   end
          'cor2' : begin 
	             maskfile=getenv('SECCHI_CAL')+'/cor2'+aorb+'_mask.fts'
	             r_occ=r_sun * 2.4
                   end
          'hi1'  : maskfile=''
          'hi2'  : maskfile=getenv('SECCHI_CAL')+'/hi2'+aorb+'_mask.fts'
          'euvi' : maskfile=getenv('SECCHI_CAL')+'/euvi_mask.fts'
          ELSE   : maskfile=''
        ENDCASE
        if maskfile ne '' then begin
    	    print,'reading in ',maskfile
	    mskim=rebin(sccreadfits(maskfile,mhdr)+1,fhsize,fhsize)
	    hdr1=prevhdr[ab]	; actually this is the current header
	    hdr1.filename=mhdr.filename
    	    IF keyword_set(TWO) THEN mvmsk[ab,*,*]=scc_normalize(mskim,hdr1,ref_hdr=hdra) ELSE mvmsk[ab,*,*]=mskim
    	    IF datatype(mskhdr) EQ 'UND' THEN mskhdr=make_array(2,value=def_secchi_hdr())
    	    mskhdr[ab]=mhdr
        endif
    endif  
      ;if n_elements(mvmsk) gt 1 then begin 
    bmask=reform(mvmsk[ab,*,*])
    ;nimage=bimage
    bimage(where(bmask LT 2))=fillcol
      ;endif  
endif  



      CASE STRLOWCASE(hdr.detector) OF
      'cor1' : BEGIN
                r_occ = r_sun * 1.2
                IF KEYWORD_SET(LG_MASK_OCC) THEN r_occ=r_sun * 1.5
                r_occ_out = r_sun * 4.0 
             END
      'cor2' : BEGIN
                if (STRLOWCASE(aorb) eq 'b') THEN r_occ = r_sun * 2.6 else r_occ = r_sun * 2.4
                IF KEYWORD_SET(LG_MASK_OCC) THEN $
		if (STRLOWCASE(aorb) eq 'b') THEN r_occ = r_sun * 3.3 else r_occ = r_sun * 3.0
                ;if(STRLOWCASE(aorb) eq 'b')THEN r_occ_out = r_sun * 16 else r_occ_out = r_sun * 15
                ; R_sun varies with time, so use fixed pixel distance - nr
		if (STRLOWCASE(aorb) eq 'b') THEN r_occ_out = 1036*img_pan else r_occ_out = 1031*img_pan
		;linethickness=5
             END
      'euvi' : BEGIN  ; "Mask Occulter" should be off for EUVI and HI instruments
               LG_MASK_OCC=0 & MASK_OCC=0 & LIMB=0 
               r_occ_out = r_sun * 1.6
             END
      ELSE : BEGIN  ; "Mask Occulter" should be off for EUVI and HI instruments
               LG_MASK_OCC=0 & MASK_OCC=0 & LIMB=0 & OUTER=0
             END
      ENDCASE

    set_plot,'z'     
    device,set_resolution=[fhsize,fhsize]
    
    IF keyword_set(OUTER)THEN BEGIN
    	; for now, do not return sunxcen and sunycen; this is computed for each frame 
	; from frame header in scc_wrunmovie.pro. -nr
    	; hdr should have correct values for WCS routine

    	tmp_img = bimage & tmp_img(*) = 0
;	WSET,2 & TV,tmp_img
        TV,tmp_img
        TVCIRCLE, r_occ_out,hdr.crpix1,hdr.crpix2, /FILL, COLOR=1
        tmp_img = TVRD()
        ind1 = WHERE(tmp_img EQ 0)
        IF (ind1[0] NE -1) THEN bimage[ind1] = fillcol
	
    ENDIF
    IF keyword_set(VERBOSE) THEN help,r_occ_out,r_occ,fillcol

;    WSET, 2
    TV, bimage

      IF (KEYWORD_SET(MASK_OCC) OR KEYWORD_SET(LG_MASK_OCC)) THEN BEGIN
         xadj=0.0 & yadj=0.0
         IF (STRLOWCASE(aorb) eq 'b' and STRLOWCASE(hdr.detector) eq 'cor2' and KEYWORD_SET(LG_MASK_OCC)) then begin
            xadj=(r_sun/3.25) & yadj=(r_sun/1.65)
         endif
	 TVCIRCLE, r_occ, sunc.xcen+xadj, sunc.ycen-yadj, /FILL, COLOR=fillcol
      ENDIF

       IF KEYWORD_SET(LIMB) THEN begin
          IF keyword_set(VERBOSE) THEN print,'sunc:',sunc, r_sun, sunc.xcen, sunc.ycen
          TVCIRCLE, r_sun, sunc.xcen, sunc.ycen, COLOR=255, THICK=linethickness
      endif

; -- END mask section
; -- Add objects HI2 only
    if keyword_set(objects) and STRLOWCASE(hdr.detector) eq 'hi2' then begin
        IF (first) THEN datecolor[ab]=255
	wcshdr=fitshead2wcs(hdr)
        objcoords=get_object_coords(hdr,wcshdr,STRLOWCASE(aorb))
        if STRLOWCASE(aorb) eq 'a' then  osc = 'B' else osc = 'A'
	xyouts,objcoords(0,0,0),objcoords(0,0,1),osc,charsize=1,color=datecolor[ab],/device
        xyouts,objcoords(1,0,0),objcoords(1,0,1),'E',charsize=1,color=datecolor[ab],/device
        xyouts,objcoords(2,0,0),objcoords(2,0,1),'S',charsize=1,color=datecolor[ab],/device
    endif

    bimage = TVRD()
;    set_plot,'x'
    select_windows

; -- BEGIN subfield extraction
    IF keyword_set(GETSUBFIELD) and (first) THEN BEGIN
    	WINDOW, 0,XSIZE = 512, YSIZE = 512
	tv,rebin(bimage,512,512)
	IF keyword_set(TWO) and (ab) THEN BEGIN
	    print,''
	    print,'ONLY HORIZONTAL POSITION WILL BE USED'
	    print,''
	ENDIF
    	box_cursor2,x1,y1,hlen,vlen,/message,/init
	; Special case for 2nd image of A/B pair - keep original size and vertical location
	IF keyword_set(VERBOSE) THEN help,x1z,y1z,hlenz,vlenz,x1,y1,hlen,vlen
	IF keyword_set(TWO) and (ab) THEN coords=[x1,x1+hlenz-1,y1z,y1z+vlenz-1]*4 $
	ELSE coords=[x1,x1+hlen-1,y1,y1+vlen-1]*4
    	IF datatype(swmoviev) NE 'UND' THEN BEGIN
    	    swmoviev.x1=coords(0)
    	    swmoviev.x2=coords(1)
    	    swmoviev.y1=coords(2)
    	    swmoviev.y2=coords(3)
	ENDIF
	img_xy=img_pan*coords
    	hsize = img_xy[1]-img_xy[0]+1
    	vsize = img_xy[3]-img_xy[2]+1
;	stop
    ENDIF
	
    IF fhsize LT foutsize THEN BEGIN
	bimage=scc_putin_array(bimage,hdr,foutsize)
	fhsize=foutsize
    ENDIF
    IF img_xy[0] NE 0 or img_xy[1] NE fhsize-1 or img_xy[2] NE 0 or img_xy[3] NE fvsize-1 THEN BEGIN
    	
        print,'Extracting ',img_xy

    	bimage = bimage[img_xy[0]:img_xy[1],img_xy[2]:img_xy[3]]           ; moved 12/20/01, nbr
    	imsz = size(bimage)

	;IF hsize MOD imsz(1) NE 0 and imsz(1) MOD hsize NE 0 THEN BEGIN
    	;    bimage = CONGRID(bimage, hsize, vsize,/interp)      
        ;    IF keyword_set(VERBOSE) THEN print,'Using CONGRID.'
	;ENDIF ELSE BEGIN
        ;    IF img0_x2-img0_x1 LT 256 or img0_y2-img0_y1 LT 256 THEN smpl = 1 ELSE smpl=0
    	;    bimage = REBIN(bimage, hsize, vsize,SAMPLE=smpl)               
	;ENDELSE
	
	; Image should only be resized in secchi_prep. nr, 12/7/07
	
	; -- Need to reset header parameters for scc_sun_center.pro
	hdr.crpix1=hdr.crpix1-coords[0]*img_pan
	hdr.crpix2=hdr.crpix2-coords[2]*img_pan
	IF keyword_set(VERBOSE) THEN print,'New crpix:',hdr.crpix1,hdr.crpix2
	; -- Reset R-vals for ccd_pos keyword in mvi header (set in sccwrite_disk_movie.pro)
	r1col=hdr.r1col
	r1row=hdr.r1row
	hdr.r1col=r1col+coords[0]
	hdr.r2col=r1col+coords[1]
	hdr.r1row=r1row+coords[2]
	hdr.r2row=r1row+coords[3]
    ENDIF
; -- END subfield

    IF (DATATYPE(hdr) EQ 'STC') THEN BEGIN
    	;efac = 1.
    	;ebias = GET_BIASMEAN(hdr,/silent) 
    	;exp_all(i) = GET_EXPTIME(hdr,/silent)
    	;bias_all(i) = ebias
    	;fpwvl=hdr.wavelnth
    	;filter=hdr.filter
    	;fpwvl_all(i)=fpwvl
    	;filter_all(i)=filter
    	;all_hdr(i) = hdr
    	;tai_all(i)= tai
	;--I believe all these arrays are unused. nr, 2/20/08
    ENDIF
    
;    IF keyword_set(LOGO) THEN bimage = SCC_ADD_mvi_LOGO(temporary(bimage))
    IF keyword_set(LOGO) THEN bimage = SCC_ADD_LOGO(temporary(bimage))

;    WINDOW, XSIZE = hsize, YSIZE = vsize, /PIXMAP ,/FREE
    ;device,set_resolution=[hsize,vsize]
    ;TV, bimage

    ftimes(yloc)= STRMID(UTC2STR(TAI2UTC(tai), /ECS, /TRUNCATE),0,tlen)

;help,i,yloc,ftimes(yloc),times

    mdnotbx=median(bimage[xouts:xouts+(hsize/6),youts:youts+20])
    IF (first) THEN IF mdnotbx GT 180 THEN datecolor[ab]=0 ELSE BEGIN
	datecolor[ab]=255	
	IF hdr.wavelnth EQ 171 THEN datecolor[ab]=240
	; something weird with this secchi_prep color table
    ENDelse

;stop
    IF keyword_set(TIMES) THEN BEGIN
	bimage=scc_add_datetime(bimage,hdr,color=datecolor[ab], /ADDCAM,MVI=times)
    ENDIF
    ; add timestamp without using tvrd() on bimage

    IF keyword_set(VERBOSE) THEN help,xouts,youts,times,mdnotbx

    ;bimage = TVRD()
    pimgsz=size(prevbimg)
    
    IF pimgsz[2] NE hsize THEN prevbimg=make_array(2,hsize,vsize,/byte)
    IF n_elements(pimgsz) GT 3 THEN if pimgsz[3] NE vsize THEN prevbimg=make_array(2,hsize,vsize,/byte)
    prevbimg[ab,*,*]=bimage
    
    hsize2=hsize
    vsize2=vsize
    IF keyword_set(TWO) and (ab) THEN BEGIN
    ; 2nd time
	;need to recreate the image with both images
	xf=1
	yf=1
	xs=0    ; for dividing line
	ys=0
	IF hsize*2 GT ss[0] and vsize*2 LT ss[1] THEN BEGIN
	    yf=2 
	    ys=2
	ENDIF ELSE BEGIN
	    xf=2
	    xs=2
	ENDELSE
	hsize2=hsize*xf+xs
	vsize2=vsize*yf+ys
    	set_plot,'z'
	device,set_resolution=[hsize2, vsize2] 
	IF strmid(cam,0,2) EQ 'hi' or two EQ 2 THEN BEGIN
	    ; reverse A and B so A is on left
	    image1=0
	    image2=1
	ENDIF ELSE BEGIN
	    image1=1
	    image2=0
	ENDELSE
    	TV, prevbimg[image1,*,*]
	TV, prevbimg[image2,*,*],hsize*(xf-1)+xs,vsize*(yf-1)+ys
	IF keyword_set(VERBOSE) THEN print,'Ahead image offset by ',trim(hsize*(xf-1)+xs),',',trim(vsize*(yf-1)+ys)
    	bimage=TVRD()
	;set_plot,'x'
	select_windows
    ENDIF    	
    
    tvlct,r,g,b,/get
    rgb=[[r],[g],[b]]

;next lines added for zbuffer change over
    
    IF ~keyword_set(nopop) THEN BEGIN
    	IF (first) THEN WINDOW, 0,XSIZE = hsize2, YSIZE = vsize2
	wset,0
    	IF keyword_set(TWO) and ~first THEN BEGIN
	    IF (ab) THEN TV, bimage
	ENDIF ELSE tv, bimage
    	IF ~keyword_set(TIMES) THEN XYOUTS,10,10, ftimes(yloc), /DEVICE, COLOR=datecolor[ab]

    ENDIF

    IF keyword_set(VERBOSE) THEN wait,2
    skipim:

    RETURN, bimage

END
